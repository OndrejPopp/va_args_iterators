/**
 * @file
 *
 * pp_iter.h
 * Some useful c preprocessor extensions for dealing with variadic macros
 *
 * @author Cormac Cannon (cormacc.public@gmail.com)
 *
 * This is auto-generated code. The generator script and further background/usage info may be found here:
 * https://github.com/cormacc/va_args_iterators
 *
 * Autogenerated on 10/05/2018 15:22
 * - Script:             pp_iterators.rb
 * - Max argument count: 256
 *
 * I initially encountered the variadic macro counting logic in this post by Laurent Deniau:
 * https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s
 * Refined by arpad. and zhangj to handle the no-argument case
 *
 * The (preferred) recursive implementations of PP_EACH, PP_EACH_IDX and PP_PAR_EACH_IDX are based on an excellent series of posts by Saad Ahmad
 # http://saadahmad.ca/cc-preprocessor-metaprogramming-2/
 *
 * The non- (or semi-) recursive PP_EACH implementation is based on this blog post by Daniel Hardman:
 * https://codecraft.co/2014/11/25/variadic-macros-tricks/
 *
 * The non-recursive PP_EACH_IDX and PP_PAR_EACH_IDX macro implementations extend the non-recursive PP_EACH implementation
 * described in this (anonymous) blog post:
 * http://ptspts.blogspot.ie/2013/11/how-to-apply-macro-to-all-arguments-of.html
 *
 * The MSVC macro expansion fix was lifted from the excellent fake function framework:
 * https://github.com/meekrosoft/fff
 */

#ifndef PP_ITER_H
#  define PP_ITER_H

#  ifdef  __cplusplus
extern "C" {
#  endif

//Defer / evaluate macros
#ifndef DEFER
  #define PP_NOP()
  #define DEFER(...) __VA_ARGS__ PP_NOP()
  #define DEFER2(...) __VA_ARGS__ DEFER(PP_NOP) ()
  #define DEFER3(...) __VA_ARGS__ DEFER2(PP_NOP) ()
  #define DEFER4(...) __VA_ARGS__ DEFER3(PP_NOP) ()
  #define DEFER5(...) __VA_ARGS__ DEFER4(PP_NOP) ()
  #define DEFER6(...) __VA_ARGS__ DEFER5(PP_NOP) ()
#endif //DEFER

#ifndef EVAL
  #define EVAL(...) _EVAL_8(__VA_ARGS__)
  #define _EVAL_1(...) __VA_ARGS__
  #define _EVAL_2(...) _EVAL_1(_EVAL_1(__VA_ARGS__))
  #define _EVAL_3(...) _EVAL_2(_EVAL_2(__VA_ARGS__))
  #define _EVAL_4(...) _EVAL_3(_EVAL_3(__VA_ARGS__))
  #define _EVAL_5(...) _EVAL_4(_EVAL_4(__VA_ARGS__))
  #define _EVAL_6(...) _EVAL_5(_EVAL_5(__VA_ARGS__))
  #define _EVAL_7(...) _EVAL_6(_EVAL_6(__VA_ARGS__))
  #define _EVAL_8(...) _EVAL_7(_EVAL_7(__VA_ARGS__))
#endif //EVAL

#ifndef EVAL_
  #define EVAL_(...) _EVAL__8(__VA_ARGS__)
  #define _EVAL__1(...) __VA_ARGS__
  #define _EVAL__2(...) _EVAL__1(_EVAL__1(__VA_ARGS__))
  #define _EVAL__3(...) _EVAL__2(_EVAL__2(__VA_ARGS__))
  #define _EVAL__4(...) _EVAL__3(_EVAL__3(__VA_ARGS__))
  #define _EVAL__5(...) _EVAL__4(_EVAL__4(__VA_ARGS__))
  #define _EVAL__6(...) _EVAL__5(_EVAL__5(__VA_ARGS__))
  #define _EVAL__7(...) _EVAL__6(_EVAL__6(__VA_ARGS__))
  #define _EVAL__8(...) _EVAL__7(_EVAL__7(__VA_ARGS__))
#endif //EVAL_


//Token concatenation (tuple-aware)
#ifndef PP_CAT
  #define PP_CAT
  // Defer the call to the CAT so that we get the updated parameters first
  #define CAT(a, b) _CAT_EVAL ( _CAT_EXPAND_PARAMETERS(a, b) )
  #define _CAT_EVAL(...) _CAT_HELPER __VA_ARGS__

  // Find the result of testing whether a macro is enclosed or not
  #define _CAT_EXPAND_PARAMETERS(a, b) (a, _CAT_PAREN_CHECK b, DEFAULT, b )
  #define _CAT_PAREN_CHECK(...) EXPANDED, ENCLOSED, (__VA_ARGS__) ) EAT (

  // Pattern match the result of testing if it is enclose or not
  #define _CAT_HELPER(a, _, f, b) _CAT_HELPER_ ## f (a, b)
  #define _CAT_HELPER_ENCLOSED(a, b) a b
  #define _CAT_HELPER_DEFAULT(a, b) a ## b
#endif //PP_CAT


//Logical operations
#ifndef PP_LOGIC
  #define PP_LOGIC
  //Usage: IF(<condition>) (<then>, <else>)
  #define  IF(value) CAT(_IF_, value)
  #define _IF_1(true, ...) true
  #define _IF_0(true, ...) __VA_ARGS__

  #define NOT(x) PP_MATCHER ( CAT(NOT_, x), 0 )
  #define NOT_0 EXISTS(1)

  //== Building blocks

  //PP_MATCHER
  #define PP_MATCHER(value, ...)   IF ( _MATCH(_MATCH_FIND(value)) )       ( _MATCH_EXTRACT(value), __VA_ARGS__ )

  #define _MATCH(x) CAT(__MATCH_, x)
  #define __MATCH_EXISTS(...) 1
  #define __MATCH_UNMATCHED 0

  #define _MATCH_FIND(x) __MATCH_RESULT_EXTRACT (  __MATCH_RESULT_FIND(x) )

  /**
   * Extract 2nd element of a match result in the format:
   * (IGNORED, EXISTS(DEFINED_VALUE)) or (IGNORED, UNMATCHED)
   * This is appended to __MATCH_ to convert result to a boolean,
   */
  #define __MATCH_RESULT_EXTRACT(x) __MATCH_RESULT_EXTRACT_HELPER  x
  #define __MATCH_RESULT_EXTRACT_HELPER(match, return_value) return_value

  /**
   * __MATCH_RESULT_FIND( EXISTS(bla) ) returns ( EXPANDED, EXISTS(bla) )
   * __MATCH_RESULT_FIND( bla ) returns ( TEST_bla, UNMATCHED)
   */
  #define __MATCH_RESULT_FIND(x) ( CAT(__MATCH_RESULT_EXPAND_, x),  UNMATCHED )
  #define __MATCH_RESULT_EXPAND_EXISTS(...) EXPANDED, EXISTS(__VA_ARGS__) ) EAT (
  #define EAT(...)

  //_MATCH_EXTRACT / __MATCH_EXTRACT_EXISTS
  #define _MATCH_EXTRACT(value) CAT(__MATCH_EXTRACT_, value)
  #define __MATCH_EXTRACT_EXISTS(...) __VA_ARGS__
#endif //PP_LOGIC


//Lists (HEAD, TAIL, ISEMPTY etc.)
#ifndef PP_LISTS
  #define PP_LISTS
  #define HEAD(FIRST, ...) FIRST
  #define TAIL(FIRST, ...) __VA_ARGS__

  #define TEST_LAST EXISTS(1)
  #define IS_EMPTY(...)   PP_MATCHER(     DEFER(HEAD) (__VA_ARGS__ EXISTS(1))  , 0)
  #define NOT_EMPTY(...) NOT(IS_EMPTY(__VA_ARGS__))
#endif //PP_LISTS


//Tuples
#ifndef PP_TUPLES
  #define PP_TUPLES
  #define PAREN(...) ( __VA_ARGS__ )
  #define DEPAREN(...) DEPAREN_ __VA_ARGS__
  #define DEPAREN_(...) __VA_ARGS__

  #define IS_ENCLOSED(x, ...) PP_MATCHER ( IS_ENCLOSED_TEST x, 0 )
  #define IS_ENCLOSED_TEST(...) EXISTS(1)

  #define IF_ENCLOSED(...) CAT(_IF_ENCLOSED_, IS_ENCLOSED(__VA_ARGS__))
  #define _IF_ENCLOSED_0(true, ...) __VA_ARGS__
  #define _IF_ENCLOSED_1(true, ...) true
  // This function will optionally remove parentheses around its arguments
  // if there are any. Otherwise it will return normally
  #define OPT_DEPAREN(...)   IF_ENCLOSED (__VA_ARGS__) ( DEPAREN(__VA_ARGS__), __VA_ARGS__ )
#endif //PP_TUPLES


//Argument counting
#ifndef PP_UTIL
  #define PP_UTIL
  #define EXPAND(x) x
  #define PP_SEQ_N() 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256
  #define PP_RSEQ_N() 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
#endif //PP_UTIL

#ifndef PP_NARG
  #define PP_NARG(...)  EXPAND(PP_ARG_N(_0, ##__VA_ARGS__, PP_RSEQ_N()))
  #define PP_ARG_N(...) EXPAND(_PP_ARG_N(__VA_ARGS__))
  #define _PP_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128, _129, _130, _131, _132, _133, _134, _135, _136, _137, _138, _139, _140, _141, _142, _143, _144, _145, _146, _147, _148, _149, _150, _151, _152, _153, _154, _155, _156, _157, _158, _159, _160, _161, _162, _163, _164, _165, _166, _167, _168, _169, _170, _171, _172, _173, _174, _175, _176, _177, _178, _179, _180, _181, _182, _183, _184, _185, _186, _187, _188, _189, _190, _191, _192, _193, _194, _195, _196, _197, _198, _199, _200, _201, _202, _203, _204, _205, _206, _207, _208, _209, _210, _211, _212, _213, _214, _215, _216, _217, _218, _219, _220, _221, _222, _223, _224, _225, _226, _227, _228, _229, _230, _231, _232, _233, _234, _235, _236, _237, _238, _239, _240, _241, _242, _243, _244, _245, _246, _247, _248, _249, _250, _251, _252, _253, _254, _255, _256, _257, N, ...) N
#endif //PP_NARG


//PP_EACH
#ifndef PP_EACH
  #define PP_EACH(TF, ...) \
    EVAL(_PP_EACH_DEFER(TF, __VA_ARGS__))

  #define _PP_EACH_DEFER(TF, ...) \
    IF ( NOT_EMPTY( __VA_ARGS__ )  ) \
    ( \
      DEFER(TF) (OPT_DEPAREN(HEAD(__VA_ARGS__))) \
      DEFER2 ( __PP_EACH_DEFER ) () (TF, TAIL(__VA_ARGS__)) \
    )

  //This indirection along with the DEFER2 and EVAL macros allows the recursive implementation of _PP_EACH_DEFER
  #define __PP_EACH_DEFER() _PP_EACH_DEFER
#endif //PP_EACH


//PP_EACH_IDX
#ifndef PP_EACH_IDX
  #define PP_EACH_IDX(TF, ...) EVAL(_PP_EACH_IDX_DEFER(TF, (PP_SEQ_N()), __VA_ARGS__))

  #define _PP_EACH_IDX_DEFER(TF, VA_INDICES, ...) \
      IF ( NOT_EMPTY( __VA_ARGS__ )  ) \
      ( \
        DEFER2(TF) (OPT_DEPAREN(HEAD(__VA_ARGS__)), DEFER(HEAD)(DEPAREN(VA_INDICES))) \
        DEFER2 ( __PP_EACH_IDX_DEFER ) () (TF, (TAIL VA_INDICES), TAIL(__VA_ARGS__)) \
      )

    #define __PP_EACH_IDX_DEFER() _PP_EACH_IDX_DEFER
#endif //PP_EACH_IDX


//PP_PAR_EACH_IDX
#ifndef PP_PAR_EACH_IDX
  #define PP_PAR_EACH_IDX(TF, FARGS, ...) EVAL(_PP_PAR_EACH_IDX_DEFER(TF, FARGS, (PP_SEQ_N()), __VA_ARGS__))

  #define _PP_PAR_EACH_IDX_DEFER(TF, FARGS, VA_INDICES, ...)                         \
    IF ( NOT_EMPTY( __VA_ARGS__ )  )                                      \
    (                                                                     \
      DEFER2(TF) (OPT_DEPAREN(FARGS), OPT_DEPAREN(HEAD(__VA_ARGS__)), DEFER(HEAD)(DEPAREN(VA_INDICES))) \
      DEFER2 ( __PP_PAR_EACH_IDX_DEFER ) () (TF, FARGS, (TAIL VA_INDICES), TAIL(__VA_ARGS__)) \
    )

  #define __PP_PAR_EACH_IDX_DEFER() _PP_PAR_EACH_IDX_DEFER
#endif //PP_PAR_EACH_IDX


//PP_xPAR_EACH_IDX (Wrappers for deprecated macros)
#define PP_1PAR_EACH_IDX(TF, P1, ...) PP_PAR_EACH_IDX(TF, (P1), __VA_ARGS__)

#define PP_2PAR_EACH_IDX(TF, P1, P2, ...) PP_PAR_EACH_IDX(TF, (P1, P2), __VA_ARGS__)


#  ifdef  __cplusplus
}
#  endif

#endif  /* PP_ITER_H */
