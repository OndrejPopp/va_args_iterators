/**
 * @file
 *
 * pp_iter.h
 * Some useful c preprocessor extensions for dealing with variadic macros
 *
 * @author Cormac Cannon (cormacc.public@gmail.com)
 *
 * This is auto-generated code. The generator script and further background/usage info may be found here:
 * https://github.com/cormacc/va_args_iterators
 *
 * Autogenerated on 09/05/2018 16:50
 * - Script:             pp_iterators.rb
 * - Max argument count: 64
 *
 * I initially encountered the variadic macro counting logic in this post by Laurent Deniau:
 * https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s
 * Refined by arpad. and zhangj to handle the no-argument case
 *
 * Recursive PP_EACH implementation based on this blog post by Daniel Hardman:
 * https://codecraft.co/2014/11/25/variadic-macros-tricks/
 *
 * The PP_nPAR_EACH_IDX macro implementations extend the non-recursive PP_EACH implementation
 * described in this (anonymous) blog post:
 * http://ptspts.blogspot.ie/2013/11/how-to-apply-macro-to-all-arguments-of.html
 *
 * This MSVC macro expansion fix was lifted from the excellent fake function framework:
 * https://github.com/meekrosoft/fff
 */

#ifndef PP_ITER_H
#  define PP_ITER_H

#  ifdef  __cplusplus
extern "C" {
#  endif

//Defer / evaluate macros
#ifndef DEFER
  #define PP_NOP()
  #define DEFER(...) __VA_ARGS__ PP_NOP()
  #define DEFER2(...) __VA_ARGS__ DEFER(PP_NOP) ()
  #define DEFER3(...) __VA_ARGS__ DEFER2(PP_NOP) ()
  #define DEFER4(...) __VA_ARGS__ DEFER3(PP_NOP) ()
  #define DEFER5(...) __VA_ARGS__ DEFER4(PP_NOP) ()
  #define DEFER6(...) __VA_ARGS__ DEFER5(PP_NOP) ()
  #define DEFER7(...) __VA_ARGS__ DEFER6(PP_NOP) ()
  #define DEFER8(...) __VA_ARGS__ DEFER7(PP_NOP) ()
#endif //DEFER

#ifndef EVAL
  #define EVAL(...) _EVAL_8(__VA_ARGS__)
  #define _EVAL_1(...) __VA_ARGS__
  #define _EVAL_2(...) _EVAL_1(_EVAL_1(__VA_ARGS__))
  #define _EVAL_3(...) _EVAL_2(_EVAL_2(__VA_ARGS__))
  #define _EVAL_4(...) _EVAL_3(_EVAL_3(__VA_ARGS__))
  #define _EVAL_5(...) _EVAL_4(_EVAL_4(__VA_ARGS__))
  #define _EVAL_6(...) _EVAL_5(_EVAL_5(__VA_ARGS__))
  #define _EVAL_7(...) _EVAL_6(_EVAL_6(__VA_ARGS__))
  #define _EVAL_8(...) _EVAL_7(_EVAL_7(__VA_ARGS__))
#endif //EVAL

#ifndef EVAL_
  #define EVAL_(...) _EVAL__8(__VA_ARGS__)
  #define _EVAL__1(...) __VA_ARGS__
  #define _EVAL__2(...) _EVAL__1(_EVAL__1(__VA_ARGS__))
  #define _EVAL__3(...) _EVAL__2(_EVAL__2(__VA_ARGS__))
  #define _EVAL__4(...) _EVAL__3(_EVAL__3(__VA_ARGS__))
  #define _EVAL__5(...) _EVAL__4(_EVAL__4(__VA_ARGS__))
  #define _EVAL__6(...) _EVAL__5(_EVAL__5(__VA_ARGS__))
  #define _EVAL__7(...) _EVAL__6(_EVAL__6(__VA_ARGS__))
  #define _EVAL__8(...) _EVAL__7(_EVAL__7(__VA_ARGS__))
#endif //EVAL_


//Token concatenation (tuple-aware)
#ifndef PP_CAT
  #define PP_CAT
  // Find the result of testing whether a macros is enclosed or not
  #define ENCLOSE_EXPAND(...) EXPANDED, ENCLOSED, (__VA_ARGS__) ) EAT (
  #define GET_CAT_EXP(a, b) (a, ENCLOSE_EXPAND b, DEFAULT, b )
  
  // Pattern match the result of testing if it is enclose or not
  #define CAT_WITH_ENCLOSED(a, b) a b
  #define CAT_WITH_DEFAULT(a, b) a ## b
  #define CAT_WITH(a, _, f, b) CAT_WITH_ ## f (a, b)
  
  // Defer the call to the CAT so that we get the updated parameters first
  #define EVAL_CAT_WITH(...) CAT_WITH __VA_ARGS__
  #define CAT(a, b) EVAL_CAT_WITH ( GET_CAT_EXP(a, b) )
  
#endif //PP_CAT


//Logical operations
#ifndef PP_LOGIC
  #define PP_LOGIC
  #define  IF(value) CAT(_IF_, value)
  #define _IF_1(true, ...) true
  #define _IF_0(true, ...) __VA_ARGS__
  
  #define NOT_0 EXISTS(1)
  #define NOT(x) TRY_EXTRACT_EXISTS ( CAT(NOT_, x), 0 )
  
  #define EAT(...)
  #define EXPAND_TEST_EXISTS(...) EXPANDED, EXISTS(__VA_ARGS__) ) EAT (
  #define GET_TEST_EXISTS_RESULT(x) ( CAT(EXPAND_TEST_, x),  DOESNT_EXIST )
  #define GET_TEST_EXIST_VALUE_(expansion, existValue) existValue
  #define GET_TEST_EXIST_VALUE(x) GET_TEST_EXIST_VALUE_  x
  
  #define TEST_EXISTS(x) GET_TEST_EXIST_VALUE (  GET_TEST_EXISTS_RESULT(x) )
  
  #define DOES_VALUE_EXIST_EXISTS(...) 1
  #define DOES_VALUE_EXIST_DOESNT_EXIST 0
  #define DOES_VALUE_EXIST(x) CAT(DOES_VALUE_EXIST_, x)
  
  #define EXTRACT_VALUE_EXISTS(...) __VA_ARGS__
  #define EXTRACT_VALUE(value) CAT(EXTRACT_VALUE_, value)
  
  #define TRY_EXTRACT_EXISTS(value, ...)   IF ( DOES_VALUE_EXIST(TEST_EXISTS(value)) )       ( EXTRACT_VALUE(value), __VA_ARGS__ )
  
  
#endif //PP_LOGIC


//Lists (HEAD, TAIL, ISEMPTY etc.)
#ifndef PP_LISTS
  #define PP_LISTS
  #define HEAD(FIRST, ...) FIRST
  #define TAIL(FIRST, ...) __VA_ARGS__
  
  #define TEST_LAST EXISTS(1)
  #define IS_EMPTY(...)   TRY_EXTRACT_EXISTS(     DEFER(HEAD) (__VA_ARGS__ EXISTS(1))  , 0)
  #define NOT_EMPTY(...) NOT(IS_EMPTY(__VA_ARGS__))
  
  
#endif //PP_LISTS


//Tuples
#ifndef PP_TUPLES
  #define PP_TUPLES
  #define PAREN(...) ( __VA_ARGS__ )
  #define DEPAREN(...) DEPAREN_ __VA_ARGS__
  #define DEPAREN_(...) __VA_ARGS__
  
  #define IS_ENCLOSED(x, ...) TRY_EXTRACT_EXISTS ( IS_ENCLOSED_TEST x, 0 )
  #define IS_ENCLOSED_TEST(...) EXISTS(1)
  
  #define IF_ENCLOSED(...) CAT(_IF_ENCLOSED_, IS_ENCLOSED(__VA_ARGS__))
  #define _IF_ENCLOSED_0(true, ...) __VA_ARGS__
  #define _IF_ENCLOSED_1(true, ...) true
  // This function will optionally remove parentheses around its arguments
  // if there are any. Otherwise it will return normally
  #define OPT_DEPAREN(...)   IF_ENCLOSED (__VA_ARGS__) ( DEPAREN(__VA_ARGS__), __VA_ARGS__ )
  
  
#endif //PP_TUPLES


//Argument counting
#ifndef PP_UTIL
  #define PP_UTIL
  #define EXPAND(x) x
  #define PP_SEQ_N() 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64
  #define PP_RSEQ_N() 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
#endif //PP_UTIL

#ifndef PP_NARG
  #define PP_NARG(...)  EXPAND(PP_ARG_N(_0, ##__VA_ARGS__, PP_RSEQ_N()))
  #define PP_ARG_N(...) EXPAND(_PP_ARG_N(__VA_ARGS__))
  #define _PP_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, N, ...) N
#endif //PP_NARG


//PP_EACH
#ifndef PP_EACH
  #define PP_EACH(TF, ...) \
    EVAL(_PP_EACH_DEFER(TF, __VA_ARGS__))
  
  #define _PP_EACH_DEFER(TF, ...) \
    IF ( NOT_EMPTY( __VA_ARGS__ )  ) \
    ( \
      DEFER(TF) (OPT_DEPAREN(HEAD(__VA_ARGS__))) \
      DEFER2 ( __PP_EACH_DEFER ) () (TF, TAIL(__VA_ARGS__)) \
    )
  
  //This indirection along with the DEFER2 and EVAL macros allows the recursive implementation of _PP_EACH_DEFER
  #define __PP_EACH_DEFER() _PP_EACH_DEFER
  
#endif //PP_EACH


//PP_EACH_IDX
#ifndef PP_EACH_IDX
  #define PP_EACH_IDX(TF, ...) EVAL(_PP_EACH_IDX_DEFER(TF, (PP_SEQ_N()), __VA_ARGS__))
  
  #define _PP_EACH_IDX_DEFER(TF, VA_INDICES, ...) \
      IF ( NOT_EMPTY( __VA_ARGS__ )  ) \
      ( \
        DEFER2(TF) (OPT_DEPAREN(HEAD(__VA_ARGS__)), DEFER(HEAD)(DEPAREN(VA_INDICES))) \
        DEFER2 ( __PP_EACH_IDX_DEFER ) () (TF, (TAIL VA_INDICES), TAIL(__VA_ARGS__)) \
      )
  
    #define __PP_EACH_IDX_DEFER() _PP_EACH_IDX_DEFER
  
#endif //PP_EACH_IDX


//PP_PAR_EACH_IDX
//{parameterised_each_with_index}

//PP_xPAR_EACH_IDX (Wrappers for deprecated macros)
//{parameterised_each_with_index_n(1)}
//{parameterised_each_with_index_n(2)}

#  ifdef  __cplusplus
}
#  endif

#endif  /* PP_ITER_H */
